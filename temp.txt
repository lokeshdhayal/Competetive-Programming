

3 5

0 3 -> 3
1 3 -> 2
2 3 -> 1 
3 3 -> 0
4 3 -> 7
5 3 -> 6 
6 3 -> 5
7 3 -> 4

4 6

100

0 4 -> 4
1 4 -> 5
2 4 -> 6
3 4 -> 7
4 4 -> 0
5 4 -> 1
6 4 -> 2

100 ^ 011   110



gcd(a + x, m) = gcd(a , m) -> g

gcd(y , m/g) = 1


n x => n%x == 0 && n%(n/x) == 0 

6 -> 1 2 3 6About prime number

6 1 1  -> 6 * 3
1 2 3  -> 6 * 3
C(n,2) + C(n,4) + ....
16

1 2 4 8 16
k = 4
16 1 1 1 
8 1 1 1 , 8 4 2 1 , 8 2 2 2  



1 -> 16 
8 -> 8 , 3 -> 2^3 -> (3!*(!0) + 2!*(!1) + 1!*()) 
log(n)
1

7 , 0 , 5  -> 49 + 25 -> 74
0 , 7 , 5  -> 1 + 

111
101
001

100 -> 4
011 -> 3
101 -> 5
2 -> 2
1 -> 1
2 -> 2

101

n/1 (n)/2 n/4 n/8

(m*n - 1) -> a , b , c , d -> a & b & c & d


3 4
7 3     3 1
4 (8,4) 3 6
7 7     7 4

111 100
7 3 3 1
4 


1110    1    1    1  1
1110 1110 1110 1110  1


(1 << 5)  3        3 3 3
(1 << 5)  (1 << 5) ...   


2
1 2
1 3
2
1

 3
 1
10
11
 1 10
 1 11 -> ok
10 11 -> NO



 4
  1
 10
 11
100
1 10 -> ok
1 11 -> ok
1 100 -> 1 100

1 -> 1

-(n/(1 << (k + 1)) - n/(1 << (k)))



xor > sum ->no 
a ^ b = xor
a + b = sum
a = sum - b

(sum - b) ^ b = xor

sum ^ b = xor
b = xor ^ sum , a = sum - b

10
2 1

1000 101 -> 1101 13

10000 100000

010
100

 11
  1

gcd(a , b) = gcd(a + b , b) = gcd(a , b - a)

gcd(a1 + b1 , a2 + b1 , ....) => gcd(a1 + b1 , a2 - a1 , 3 - )




0001 -> 0010 -> 
0010
100 & 101 -> 100



11 -> 01 >> 11 >> 10
100 >> 000
1 >> 1 -> 10
10 >>  10 >> 0
11 >> 1 >> 10 >> 11
100 >> 100
101 >> 100 >> 1 >> 101

100000000010 1 >> 10 >> 

1011
1010 >> 10 >> 1000 >> 1010
1100
10010
11

1011
-1100
1101
1110
1111

3 4 1
5 4 2
3 3 3


3 3 2
3 4 1
5 4 2


 2 3 3 5 6 7 11 14

1 2 3 3 4 5 6 7 14


x -> our choice


2
6
LRRRLL
3
LRL


2 -> 1 5 5
1 -> 4     15 
4+ 4 <= 4


1 2 4
1 5



2 3   -> pick -> 4
1   5


M  -> dp variable -> 1e9 -> huge

8 12 8 12


[1 , -3 , -1 , 3]




0 -> 
1 -> 3
2 -> 2

dp[0][0] = 1;

n * log(n) * 10

10^5 * 20 * 10
2 * (10 ^ 7)
cost of path -> wight
dis of path -> minimum cost of path


4 3
4 3 2 1
1 0.3
3 1
4 0.6

2 3 4

1 2 3 4 5


n/2


It's Impossible -> find gcd of n/2
 
 4 5
 5 3


-> tommoro -> 



n k p

n/k + (n - 1)/k + (n - 2)/k + (p)/k

(n + n - 1 + n - 2 + n - 2)/k

(n * p - (p - 1))/k

b%c == 0

c -> one of b's divisors


sum += all(sum);

18

 7  6  32
31 34  50
 7 -> 6 -> 32


11 22 30
46 41 49

11 + 22 + 30

 3 16 24 21 21
31 24 36 49 50

3 + 16 21


->watch the videos and learn new concepts I'am on day 3
1. Number Theory -> 4
2. Network Flow -> 1-2-3
3. Data Structure -> 3-4
4. Geomatry -> 2-3
5. Binary Ternary Search -> 3-4
6. Fenwick tree , Segment tree , Disjoint -> ?
6. Dp -> 4-5
7. Tree -> 3 - 4 - 5
8. Graph -> 3-4




2 

0 1 2 3 5
0 0 0 0 1 1 2 4 8 16 31 



1000000000000170
10000000000036
1000000000033
100000000018


5 1 1 5
4 4 2 5
2 2 2 5
3 3 2 5

2 2
3 3
4 4
5 1  1 5



1 5
2 2
3 3
4 4

1 6 0 7 16 0 0 -2 0
1 -> 1
0 -> 4


->    <-   ->  <-   ->

0 0 1 0


1. One Page Application
2. Open wide library to use -> class functions -> Redux -> testing app
3. Frontent -> 



JSX -> js XML  
func(){
	console.log("HEllo Lokesh");
	return <h1>Hello LokeSh</h1>
} 


stats -> properties of class
Hooks -> 


Constructor -> used to initialize the things 
ComponentDidMount
ComponntWill

Props Stats -> 
var a = 6;
a = 3;
console.log(a); -> 3

Stats -> can't  
Sql -> Select from -> query
Model -> class 
->Name 10th 12th college certificate 


0 2 3 4 6

2

bac

[
1 1 1
1 1 1
]

pi * r * r * l
pi/4

1 cm^3
pi*r*r*l + x*pi*r*r = x;
x = pi*r*r*l/(v subl- pi*r*r);
pi/4 = x(d - pi/4);
pi/4 = x(4*d - pi)/4

x = pi/(4 - pi)

x = pi/(4*d - pi)
